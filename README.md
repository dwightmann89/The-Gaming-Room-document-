# The-Gaming-Room-document-
Software Document 
The client, The Gaming Room, came to us with a clear vision—they wanted to take their Android game Draw It or Lose It and expand it into a web-based platform that could run smoothly across multiple operating systems. They needed more than just a simple port; the new version had to support multiple teams and players, guarantee unique game and team names, and maintain a single active instance of each game at a time.

One thing I’m particularly proud of in my documentation is how clearly I was able to capture and translate their needs into a solid design plan. From the requirements list to the UML diagrams, I focused on making the structure of the system easy to understand, both for myself as a developer and for anyone else who might work on the project later. That clarity gave me a roadmap I could trust when moving into the coding phase.

Working through the design document was incredibly helpful—it forced me to think deeply before touching a single line of code. Breaking down the requirements into smaller, concrete components gave me a sense of control over the project. It was like building the blueprint for a house before picking up a hammer—everything felt more intentional and well thought out.

If I had the chance to go back and revise one part, I’d expand the recommendations section. I think including more detail on the pros and cons of different server environments, and maybe exploring alternative architecture options, would make the design even stronger. That extra context could help the client make more informed decisions.

When it came to interpreting the user’s needs, I tried to put myself in their shoes—not just as the client, but as the end users who would actually play the game. That’s why unique naming rules, cross-platform access, and seamless performance were built into the design from the start. Considering the user’s needs isn’t just a nice-to-have—it’s the difference between software that works and software that people love to use.

My approach was straightforward but deliberate: gather requirements, translate them into a domain model, apply architectural constraints, and recommend the most fitting platforms. In future projects, I’ll keep that same method, but I’d also add more prototyping and early user feedback to validate assumptions. There’s something exciting about that moment when a design shifts from abstract ideas to something real that people can interact with—and I want to make that transition as smooth and user-focused as possible.

